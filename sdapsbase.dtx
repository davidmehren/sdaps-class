% \iffalse meta-comment
%
% Copyright (C) 2015 by Benjamin Berg <benjamin@sipsolutions.net>
%
% This work may be distributed and/or modified under the
% conditions of the LaTeX Project Public License, either version 1.3
% of this license or (at your option) any later version.
% The latest version of this license is in
%   http://www.latex-project.org/lppl.txt
% and version 1.3 or later is part of all distributions of LaTeX
% version 2005/12/01 or later.
%
% This work has the LPPL maintenance status `maintained'.
% 
% The Current Maintainer of this work is Benjamin Berg.
%
% \fi
%
% \iffalse
%<*driver>
\ProvidesFile{sdapsbase.dtx}
%</driver>
%<package>\NeedsTeXFormat{LaTeX2e}[1999/12/01]
%<package>\ProvidesPackage{sdapsbase}
%<*package>
    [2015/01/14 v0.1 Initial version of SDAPS base package]
%</package>
%
%<*driver>
\documentclass{ltxdoc}
\usepackage{sdapsbase}[2015/01/14]
%\EnableCrossrefs
\CodelineIndex
\RecordChanges
\begin{document}
  \DocInput{sdapsbase.dtx}
\end{document}
%</driver>
% \fi
%
% \CheckSum{0}
%
% \CharacterTable
%  {Upper-case    \A\B\C\D\E\F\G\H\I\J\K\L\M\N\O\P\Q\R\S\T\U\V\W\X\Y\Z
%   Lower-case    \a\b\c\d\e\f\g\h\i\j\k\l\m\n\o\p\q\r\s\t\u\v\w\x\y\z
%   Digits        \0\1\2\3\4\5\6\7\8\9
%   Exclamation   \!     Double quote  \"     Hash (number) \#
%   Dollar        \$     Percent       \%     Ampersand     \&
%   Acute accent  \'     Left paren    \(     Right paren   \)
%   Asterisk      \*     Plus          \+     Comma         \,
%   Minus         \-     Point         \.     Solidus       \/
%   Colon         \:     Semicolon     \;     Less than     \<
%   Equals        \=     Greater than  \>     Question mark \?
%   Commercial at \@     Left bracket  \[     Backslash     \\
%   Right bracket \]     Circumflex    \^     Underscore    \_
%   Grave accent  \`     Left brace    \{     Vertical bar  \|
%   Right brace   \}     Tilde         \~}
%
%
% \changes{v0.1}{2015/01/14}{Initial version}
%
% \GetFileInfo{sdapsbase.dtx}
%
% \DoNotIndex{\newcommand,\newenvironment}
% 
%
% \title{The \textsf{sdapsbase} package\thanks{This document
%   corresponds to \textsf{sdapsbase}~\fileversion, dated \filedate.}}
% \author{Benjamin Berg \\ \texttt{benjamin@sipsolutions.net}}
%
% \maketitle
%
% \section{Introduction}
%
% Put text here.
%
% \section{Usage}
%
% Put text here.
%
% \StopEventually{\PrintChanges\PrintIndex}
%
% \section{Implementation}
%
% This package uses the \LaTeX3 language internally, so we need to enable it.
%    \begin{macrocode}
% We need at least 2011-08-23 for \keys_set_known:nnN
\RequirePackage{expl3}[2011/08/23]
\RequirePackage{xparse}
\ExplSyntaxOn
%    \end{macrocode}
%
% And we need a number of other packages.
%    \begin{macrocode}
\ExplSyntaxOff

\input{code128}

\RequirePackage{qrcode}

\RequirePackage{tikz}
\usetikzlibrary{calc}
\usetikzlibrary{positioning}
\usetikzlibrary{decorations.pathmorphing}
\ExplSyntaxOn


% Define aliases for code128 functions, and generate variants
\tex_let:D \code_render:n \code
\cs_generate_variant:Nn \code_render:n { x, V }

\cs_new_protected:Nn \qrcode_render:nn {
  \qrcode[#1] {#2}
}
\cs_generate_variant:Nn \qrcode_render:nn { nx, nV }


%    \end{macrocode}
%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%
% \subsection{Context Handling}
%
% When creating complex questionnaires we need a mechnism to handle the current
% context. By choice this mechanism works in global scope as items inside a
% nested environment (e.g. multicol) need to have an effect on items outside
% the environment. Because of this, we implement our own context, which works
% similar to TeX groups containing local definitions.
%
%    \begin{macrocode}

\cs_generate_variant:Nn \tl_if_eq:nnTF { Vn }
\cs_generate_variant:Nn \tl_if_eq:nnT { Vn }
\cs_generate_variant:Nn \int_if_odd:nTF { V }
\cs_generate_variant:Nn \int_if_odd:nF { V }
\cs_generate_variant:Nn \tl_set:Nn { Nv }
\cs_generate_variant:Nn \msg_error:nnn { nnV }
\cs_generate_variant:Nn \exp_not:n { f }


\prop_new:N \g__sdaps_current_context_prop
\tl_new:N \g__sdaps_current_context_id_tl

\tl_new:N \g__sdaps_current_context_tl

\seq_new:N \g__sdaps_context_ids_seq
\seq_new:N \g__sdaps_contexts_seq


\cs_new_protected:Nn \sdaps_context_to_gtl:N
{
  \tl_gclear:N #1
  \prop_map_inline:Nn \g__sdaps_current_context_prop {
    % Could we remove some of the braces in the TL?
    \tl_if_in:nnTF { \tex_undefined:D } { ##2 } {
      \tl_gput_right:Nn #1 {,{##1}}
    } {
      \tl_gput_right:Nn #1 {,{##1}={##2}}
    }
  }
  % Remove leading comma again
  \tl_gremove_once:Nn #1 {,}
}


% Create new context using given identifier
\cs_new_protected:Nn \sdaps_context_begin:n
{
  % We need to serialize the current context and save it away.

  \group_begin:
    % TODO: Call pre begin hooks

    % Serialize the current context
    \sdaps_context_to_gtl:N \g__sdaps_current_context_tl
    % Stuff it away in our sequence
    \seq_gput_left:NV \g__sdaps_contexts_seq \g__sdaps_current_context_tl
    \seq_gput_left:NV \g__sdaps_context_ids_seq \g__sdaps_current_context_id_tl

    \tl_gset:Nn \g__sdaps_current_context_id_tl { #1 }

    % TODO: Call Post begin hooks
  \group_end:
}

\msg_new:nnn { sdapsbase } { context_end_none_left } { There ~ is ~ no ~ context ~ to ~ end ~ left! }
\msg_new:nnn { sdapsbase } { context_end_broken } { The ~ current ~ context ~ with ~ id ~ #1 ~ may ~ not ~ be ~ ended ~ here. }

\cs_new_protected:Nn \__sdaps_context_end:
{
  \seq_if_empty:NTF \g__sdaps_context_ids_seq {
    \msg_error:nn { sdapsbase } { context_end_none_left }
  } {

    \group_begin:
    % TODO: Pre context end hook

    \sdaps_context_clear:
    \seq_gpop_left:NN \g__sdaps_contexts_seq \g__sdaps_current_context_tl
    \seq_gpop_left:NN \g__sdaps_context_ids_seq \l__sdaps_tmp_tl

    % Unpack context token list
    \sdaps_context_set:V \g__sdaps_current_context_tl

    \tl_gclear:N \g__sdaps_current_context_tl
    \tl_gset:NV \g__sdaps_current_context_id_tl \l__sdaps_tmp_tl

    % TODO: Post context end hook
    \group_end:
  }
}

\bool_new:N \l__sdaps_tmp_bool

\cs_new_protected:Nn \__sdaps_test_context_id:n
{
  \tl_if_eq:VnTF \g__sdaps_current_context_id_tl { #1 } {
    \bool_set:Nn \l__sdaps_tmp_bool \c_true_bool
  } {
    \bool_set:Nn \l__sdaps_tmp_bool \c_false_bool
  }
}

% Exit first context with passed in identifier
\cs_new_protected:Nn \sdaps_context_end:n
{
  \__sdaps_test_context_id:n { #1 }

  \bool_until_do:nn { \l__sdaps_tmp_bool } {
    \sdaps_context_end:

    \__sdaps_test_context_id:n { #1 }
  }
  \sdaps_context_end:
}

\cs_new_protected:Nn \__sdaps_context_end_local_scope:
{
  \__sdaps_test_context_id:n { sdaps_local_scope }

  \bool_until_do:nn { \l__sdaps_tmp_bool } {
    \__sdaps_context_end:

    \__sdaps_test_context_id:n { sdaps_local_scope }
  }
  \__sdaps_context_end:
}

% Exit current context
\cs_new_protected:Nn \sdaps_context_end:
{
  % Ensure the current context is not a local group
  \tl_if_eq:VnTF \g__sdaps_current_context_id_tl { sdaps_local_scope } {
    \msg_error:nnV { sdapsbase } { context_end_broken } \g__sdaps_current_context_id_tl
  } {}

  \__sdaps_context_end:
}

% Create new context using an empty name
\cs_new_protected:Nn \sdaps_context_begin:
{
  \sdaps_context_begin:n {}
}

% Create a new sibbling for the current context
% This simply exits the current context and creates a new
% context with the same identifier.
\cs_new_protected:Nn \sdaps_context_sibbling:
{
}

\cs_new_protected:Nn \sdaps_context_begin_local:
{
  % Create a new context which will automatically be destroyed at the end of
  % the current TeX group.
  \sdaps_context_begin:n { sdaps_local_scope }
  \group_insert_after:N \__sdaps_context_end_local_scope:
}

\cs_new_protected:Nn \sdaps_context_put:n
{
  \sdaps_context_put:nn { #1 } {\tex_undefined:D}
}

\msg_new:nnn { sdapsbase } { context_key_broken } { Keys ~ may ~ not ~ contain ~ any ~ special ~ tokens! ~ However ~ the ~ key ~ #1 ~ does ~ contain ~ tokens ~ that ~ are ~ not ~ permissible! }
% Directly set a certain key
\cs_new_protected:Nn \sdaps_context_put:nn
{
  % TODO: How can I ensure that {} are not contained?
  % Though it would not be that bad actually.
  \tl_if_in:nnTF {#1} {,} {
    \msg_error:nnn { sdapsbase } { context_key_broken } {#1}
  } {
  }

  \tl_if_in:nnTF {#1} {=} {
    \msg_error:nnn { sdapsbase } { context_key_broken } {#1}
  } {
  }

  \prop_gput:Nnn \g__sdaps_current_context_prop { #1 } { #2 }
}
\cs_generate_variant:Nn \sdaps_context_put:nn { nV }

% Set a set of keys using comma separated list of key/value pairs
\cs_new_protected:Nn \sdaps_context_set:n
{
  \keyval_parse:NNn \sdaps_context_put:n \sdaps_context_put:nn { #1 }
}
\cs_generate_variant:Nn \sdaps_context_set:n {V}

\cs_new_protected:Nn \sdaps_context_get:nN
{
  \prop_get:NnN \g__sdaps_current_context_prop { #1 } #2
}

\cs_new_protected:Nn \sdaps_context_append:nn
{
  \sdaps_context_get:nN { #1 } \l__sdaps_tmp_tl
  \tl_put_right:Nn \l__sdaps_tmp_tl {,}
  \tl_put_right:Nn \l__sdaps_tmp_tl { #2 }
  \sdaps_context_put:nV { #1 } \l__sdaps_tmp_tl
}

\cs_new_protected:Nn \sdaps_context_clear:
{
  \prop_clear:N \g__sdaps_current_context_prop
}

\cs_new_protected:Nn \sdaps_context_map:N
{
  \prop_map:NN \g__sdaps_current_context_prop #1
}

\cs_new_protected:Nn \__sdaps_get_defaults:Nn
{
  \prop_get:NnN \g__sdaps_current_context_prop { #2 } #1
  \tl_if_eq:VnT #1 { \q_no_value } {
    \tl_set:Nn #1 {}
  }
}


%    \end{macrocode}
%
%
%
%
%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%
% \subsection{Data handling and override specification}
%
% Often it is useful to set certain flags for specific checkboxes. As the
% checkbox may only be generated internally by SDAPS it is impossible to pass
% a flag to it directly. Because of this \textsf{sdapsbase} has some mechanisms
% to maintain a tree with options.
%
% \begin{verbatim}
% \sdaps_overrides_init:n{*={
%   *={},
%   checkbox2={ellipse},
%   checkbox3,1={width=6mm},
% }}
% \end{verbatim}
%
%    \begin{macrocode}

\cs_generate_variant:Nn \keyval_parse:NNn { NNV }

\seq_new:N \g__sdaps_checkbox_overlays_seq
\seq_new:N \g__sdaps_textbox_overlays_seq


\prop_new:N \g__sdaps_id_to_overrides_prop
\prop_new:N \g__sdaps_overrides_prop
\prop_new:N \g__sdaps_id_overrides_prop

\cs_new_protected:Nn \__sdaps_questionnaire_overrides_set:nn
{
  \str_if_eq_x:nnTF { #1 } { * } {
    \__sdaps_parse_overrides:n{ #2 }
  } {
    \prop_put:Nnn \g__sdaps_id_to_overrides_prop { #1 } { #2 }
  }
}

\cs_new_protected:Nn \sdaps_overrides_init:n
{
  \keyval_parse:NNn \use_none:n \__sdaps_questionnaire_overrides_set:nn { #1 }
}


\cs_new_protected:Nn \__sdaps_overrides_set:nn
{
  \prop_gput:Nnn \g__sdaps_overrides_prop { #1 } { #2 }
}

\cs_new_protected:Nn \__sdaps_id_overrides_set:nn
{
  \prop_gput:Nnn \g__sdaps_id_overrides_prop { #1 } { #2 }
}

\cs_new_protected:Nn \__sdaps_parse_overrides:n
{
  \prop_clear:N \g__sdaps_overrides_prop
  \keyval_parse:NNn \use_none:n \__sdaps_overrides_set:nn { #1 }
}

\tl_new:N \l__sdaps_set_qid_tl
\cs_new_protected:Nn \__sdaps_set_qid:n
{
  \prop_gclear:N \g__sdaps_id_overrides_prop
  \prop_get:NnNT \g__sdaps_id_to_overrides_prop { #1 } \l__sdaps_set_qid_tl {
    \keyval_parse:NNV \use_none:n \__sdaps_id_overrides_set:nn \l__sdaps_set_qid_tl
  }
}



\cs_new_protected:Nn \__sdaps_append_override_options:Nnn
{
  % Global definition
  % First generic for all items
  \prop_get:NnNT \g__sdaps_overrides_prop { * } \l__sdaps_tmp_tl {
    \tl_put_right:Nn #1 {,}
    \tl_put_right:NV #1 \l__sdaps_tmp_tl
  }
  \tl_if_empty:nF { #2 } {
    % Items with same variable name
    \prop_get:NnNT \g__sdaps_overrides_prop { #2 } \l__sdaps_tmp_tl {
      \tl_put_right:Nn #1 {,}
      \tl_put_right:NV #1 \l__sdaps_tmp_tl
    }
    \tl_if_empty:nF { #3 } {
      % Items with same variable name and value
      \prop_get:NnNT \g__sdaps_overrides_prop { #2&#3 } \l__sdaps_tmp_tl {
        \tl_put_right:Nn #1 {,}
        \tl_put_right:NV #1 \l__sdaps_tmp_tl
      }
    }
  }


  % Local (questionnaire ID specific) definition
  % First generic for all items
  \prop_get:NnNT \g__sdaps_id_overrides_prop { * } \l__sdaps_tmp_tl {
    \tl_put_right:Nn #1 {,}
    \tl_put_right:NV #1 \l__sdaps_tmp_tl
  }
  \tl_if_empty:nF { #2 } {
    % Items with same variable name
    \prop_get:NnNT \g__sdaps_id_overrides_prop { #2 } \l__sdaps_tmp_tl {
      \tl_put_right:Nn #1 {,}
      \tl_put_right:NV #1 \l__sdaps_tmp_tl
    }
    \tl_if_empty:nF { #3 } {
      % Items with same variable name and value
      \prop_get:NnNT \g__sdaps_id_overrides_prop { #2&#3 } \l__sdaps_tmp_tl {
        \tl_put_right:Nn #1 {,}
        \tl_put_right:NV #1 \l__sdaps_tmp_tl
      }
    }
  }
}

%    \end{macrocode}
%
%
%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%
%
% First we define constants and global variables for later use.
%    \begin{macrocode}
\dim_new:N \g_sdaps_linewidth_dim
\g_sdaps_linewidth_dim=1bp
\tl_new:N \g__sdaps_checkbox_last_info_tl

\int_new:N \g__sdaps_checkbox_num_int
\int_set:Nn \g__sdaps_checkbox_num_int 0


\int_new:N \g__sdaps_textbox_num_int
\int_set:Nn \g__sdaps_textbox_num_int 0


\dim_new:N \l_sdaps_x_dim
\dim_new:N \l_sdaps_y_dim
\dim_new:N \l_sdaps_width_dim
\dim_new:N \l_sdaps_height_dim

\tl_new:N \l__sdaps_tmp_tl %
\dim_new:N \l__sdaps_tmpa_dim %
\dim_new:N \l__sdaps_tmpb_dim %

%    \end{macrocode}
%
% We need to be able to output data into the .sdaps file. On startup this
% output is enabled by default.
%
%    \begin{macrocode}

\iow_new:N \g_sdaps_infofile_iow
\iow_open:Nn \g_sdaps_infofile_iow { \c_job_name_tl . sdaps }


\cs_new_protected:Nn \sdaps_info_write:n
{
  \iow_shipout:Nn \g_sdaps_infofile_iow { #1 }
}
\cs_generate_variant:Nn \sdaps_info_write:n { x }

\cs_new_protected:Nn \sdaps_info_write_x:n
{
  \iow_shipout_x:Nn \g_sdaps_infofile_iow { #1 }
}
\cs_generate_variant:Nn \sdaps_info_write_x:n { x }


%    \end{macrocode}
%
% Set some options at the beginning of the document.
%    \begin{macrocode}
\AtBeginDocument{}
%    \end{macrocode}
%
% \subsection{Definition for keyword parameters}
%
%    \begin{macrocode}



\dim_new:N \l_sdaps_checkbox_linewidth_dim
\dim_new:N \l_sdaps_checkbox_width_dim
\dim_new:N \l_sdaps_checkbox_height_dim
\tl_new:N \l_sdaps_checkbox_form_tl
\tl_new:N \l_sdaps_checkbox_fill_tl
\tl_new:N \l_sdaps_checkbox_var_tl
\tl_new:N \l_sdaps_checkbox_value_tl
\tl_new:N \l_sdaps_checkbox_unknown_tl
\bool_new:N \l_sdaps_checkbox_draw_check_bool

\bool_new:N \l_sdaps_checkbox_calcpos_bool
\bool_new:N \l_sdaps_checkbox_writepos_bool


% Internal overlays
\tl_new:N \l_sdaps_overlay_centered_text_tl
\tl_new:N \l_sdaps_overlay_minipage_text_tl
\tl_new:N \l_sdaps_overlay_minipage_pos_tl
\dim_new:N \l_sdaps_overlay_minipage_pad_dim


\keys_define:nn { sdaps / checkbox }
{
  linewidth    .dim_set:N   = \l_sdaps_checkbox_linewidth_dim,
  linewidth    .initial:n   = 1bp,
  width        .dim_set:N   = \l_sdaps_checkbox_width_dim,
  width        .initial:n   = 3.5mm,
  height       .dim_set:N   = \l_sdaps_checkbox_height_dim,
  height       .initial:n   = 3.5mm,
  form         .tl_set:N    = \l_sdaps_checkbox_form_tl,
  form         .initial:n   = { box },
  var          .tl_set:N    = \l_sdaps_checkbox_var_tl,
  value        .tl_set:N    = \l_sdaps_checkbox_value_tl,

  fill         .tl_set:N    = \l_sdaps_checkbox_fill_tl,
  fill         .initial:n   = { white },

  draw_check   .bool_set:N  = \l_sdaps_checkbox_draw_check_bool,
  draw_check   .initial:n   = false,

  % Simple node overlay
  centered_text  .tl_set:N    = \l_sdaps_overlay_centered_text_tl,
  centered_text  .initial:n   = {},

  % minipage overlay
  text         .tl_set:N    = \l_sdaps_overlay_minipage_text_tl,
  text         .initial:n   = {},
  text_align   .tl_set:N    = \l_sdaps_overlay_minipage_pos_tl,
  text_align   .initial:n   = {c},
  text_padding .dim_set:N   = \l_sdaps_overlay_minipage_pad_dim,
  text_padding .initial:n   = {2bp},


  writepos     .bool_set:N  = \l_sdaps_checkbox_writepos_bool,
  writepos     .default:n   = true,
  writepos     .initial:n   = false,

  ellipse    .meta:n  = { form=ellipse },
  box        .meta:n  = { form=box },
}
%    \end{macrocode}
%
% \subsection{Checkboxes}
%
%
%    \begin{macrocode}

\cs_new_protected:Nn \__sdaps_checkbox_internal:
{
  \mbox{
    \pdfsavepos

     % Position of page and baseline offset
    \dim_set:Nn \l_sdaps_x_dim { \hoffset }
    \dim_set:Nn \l_sdaps_y_dim { \voffset + \l_sdaps_checkbox_height_dim - \dim_max:nn { 0ex } { 0.5\l_sdaps_checkbox_height_dim - 1ex + 0.5\l_sdaps_checkbox_linewidth_dim } }

    % Size
    \dim_set:Nn \l_sdaps_width_dim { \l_sdaps_checkbox_width_dim + \l_sdaps_checkbox_linewidth_dim }
    \dim_set:Nn \l_sdaps_height_dim { \l_sdaps_checkbox_height_dim + \l_sdaps_checkbox_linewidth_dim }

    \bool_if:NT \l_sdaps_checkbox_writepos_bool {
      % pdflast[xy]pos is the PDF position of the baseline at the start of the box
      % excluding the page origin offset.
      \sdaps_info_write_x:x{
        Box=Checkbox,
        \exp_not:n{\int_use:N\g_sdaps_page_int},
        \exp_not:n{\dim_eval:n} { \exp_not:f {\dim_use:N \l_sdaps_x_dim + \the\pdflastxpos sp} },
        \exp_not:n{\dim_eval:n} { \exp_not:f {\dim_use:N \l_sdaps_y_dim + \the\pdflastypos sp} },
        \dim_use:N \l_sdaps_width_dim,
        \dim_use:N \l_sdaps_height_dim,
        \tl_to_str:N\l_sdaps_checkbox_form_tl
      }
    }


    \tikz[baseline={max(0ex, 0.5\l_sdaps_checkbox_height_dim-1ex+0.5\l_sdaps_checkbox_linewidth_dim)}]{%
      \str_if_eq_x:nnT {\l_sdaps_checkbox_form_tl} {box} {
        \draw[line~width=\l_sdaps_checkbox_linewidth_dim,fill=\l_sdaps_checkbox_fill_tl] (0.5\l_sdaps_checkbox_linewidth_dim, 0) rectangle +(\l_sdaps_checkbox_width_dim, \l_sdaps_checkbox_height_dim);%
      }
      \str_if_eq_x:nnT {\l_sdaps_checkbox_form_tl} { ellipse } {
        \draw[line~width=\l_sdaps_checkbox_linewidth_dim,fill=\l_sdaps_checkbox_fill_tl] ($(0.5\l_sdaps_checkbox_linewidth_dim, 0) + (0.5\l_sdaps_checkbox_width_dim, 0.5\l_sdaps_checkbox_height_dim)$) circle [x~radius=0.5\l_sdaps_checkbox_width_dim, y~radius=0.5\l_sdaps_checkbox_height_dim];%
      }

      % For the overlay we actually position the nodes relative to the checkbox
      % and not absolute on the page.
      \dim_set:Nn \l_sdaps_x_dim { 0pt }
      \dim_set:Nn \l_sdaps_y_dim { \l_sdaps_checkbox_height_dim + 0.5\l_sdaps_checkbox_linewidth_dim }

      % Use overlay so that nothing happens if a node is larger than the checkbox
      \begin{scope}[overlay]
        \seq_map_inline:Nn \g__sdaps_checkbox_overlays_seq {##1}
      \end{scope}
    }
  }
  \bool_if:NT \l_sdaps_checkbox_calcpos_bool {
    \int_gincr:N\g__sdaps_checkbox_num_int
  }
}


\cs_new_protected:Nn \sdaps_checkbox_force:n
{
  \group_begin:

    \keys_set_known:nnN { sdaps / checkbox } { #1 } \l_sdaps_checkbox_unknown_tl
    \__sdaps_checkbox_internal:

  \group_end:
  \ignorespaces
}

\cs_new_protected:Nn \sdaps_checkbox:nn
{
  \group_begin:%

    \tl_set:Nn \l_sdaps_checkbox_unknown_tl {}

    \__sdaps_get_defaults:Nn  \l_sdaps_checkbox_unknown_tl { checkbox }
    \__sdaps_append_override_options:Nnn \l_sdaps_checkbox_unknown_tl { #1 } { #2 }

    \keys_set_known:nVN { sdaps / checkbox } \l_sdaps_checkbox_unknown_tl \l_sdaps_checkbox_unknown_tl

    \__sdaps_checkbox_internal:
  \group_end:%
  \ignorespaces
}


\cs_new_protected:Nn \sdaps_overlay_check:
{
  \bool_if:NT \l_sdaps_checkbox_draw_check_bool {
    \begin{scope}[decoration={random~steps,segment~length=4pt,amplitude=1pt}]
      \draw[line~width=\l_sdaps_checkbox_linewidth_dim, decorate] ($(0, 0) - (2pt,2pt)$) -- (0.5\l_sdaps_checkbox_width_dim, 0.5\l_sdaps_checkbox_height_dim) -- ($(\l_sdaps_checkbox_width_dim, \l_sdaps_checkbox_height_dim) + (2pt,2pt)$);%
      \draw[line~width=\l_sdaps_checkbox_linewidth_dim, decorate] ($(0, \l_sdaps_checkbox_height_dim) + (-2pt,2pt)$) -- (0.5\l_sdaps_checkbox_width_dim, 0.5\l_sdaps_checkbox_height_dim) -- ($(\l_sdaps_checkbox_width_dim, 0) + (2pt,-2pt)$);%
    \end{scope}
  }
}
\seq_put_left:Nn \g__sdaps_checkbox_overlays_seq \sdaps_overlay_check:


\cs_new_protected:Nn \sdaps_overlay_centered:
{
  \tl_if_empty:NF \l_sdaps_overlay_centered_text_tl {
    \node[anchor=center,inner~sep=0pt,outer~sep=0pt] at ($(\l_sdaps_x_dim, \l_sdaps_y_dim) + 0.5*(\l_sdaps_width_dim, -\l_sdaps_height_dim)$) {
      \l_sdaps_overlay_centered_text_tl
    };
  }
}
\seq_put_left:Nn \g__sdaps_checkbox_overlays_seq \sdaps_overlay_centered:
\seq_put_left:Nn \g__sdaps_textbox_overlays_seq \sdaps_overlay_centered:


\cs_new_protected:Nn \sdaps_overlay_minipage:
{
  \tl_if_empty:NF \l_sdaps_overlay_minipage_text_tl {
    \node[anchor=center,inner~sep=0pt,outer~sep=0pt] at ($(\l_sdaps_x_dim, \l_sdaps_y_dim) + 0.5*(\l_sdaps_width_dim, -\l_sdaps_height_dim)$) {
      \dim_set:Nn \l_sdaps_width_dim { \l_sdaps_width_dim - 2\l_sdaps_overlay_minipage_pad_dim }
      \dim_set:Nn \l_sdaps_height_dim { \l_sdaps_height_dim - 2\l_sdaps_overlay_minipage_pad_dim }

      \begin{minipage}[t][\l_sdaps_height_dim][\l_sdaps_overlay_minipage_pos_tl]{\l_sdaps_width_dim}
        % Hm, is this sane?
        \tex_let:D \textheight\l_sdaps_height_dim
        \l_sdaps_overlay_minipage_text_tl
      \end{minipage}
    };
  }
}
\seq_put_left:Nn \g__sdaps_checkbox_overlays_seq \sdaps_overlay_minipage:
\seq_put_left:Nn \g__sdaps_textbox_overlays_seq \sdaps_overlay_minipage:



%\let\checkbox\sdaps_checkbox_force:n

%    \end{macrocode}
%


% \subsection{Textboxes}
%
%
%    \begin{macrocode}

\dim_new:N \l__sdaps_textbox_dp_dim
\dim_new:N \l__sdaps_textbox_ht_dim
\dim_new:N \l__sdaps_textbox_wd_dim
\dim_new:N \l__sdaps_textbox_pad_dim


\msg_new:nnn { sdapsbase } { textbox_wrong_mode } { Impossible~to~layout~a~#1~textbox~in~#2~mode. }

\cs_new_protected:Nn \__sdaps_textbox_vhstretch:n
{
%    \end{macrocode}
%
% At first we need to ensure that we are currently neither in inner nor math mode.
% The scaling feature simply does not work in either of these two modes.
%
%    \begin{macrocode}
  \if_mode_math:
    \msg_error:nnnn { sdapsbase } { textbox_wrong_mode } { vhstretch } { math }
  \fi:

  \if_mode_inner:
    \msg_error:nnnn { sdapsbase } { textbox_wrong_mode } { vhstretch } { inner }
  \fi:
%    \end{macrocode}
%
% If the mode is currently horizontal, then we switch back to vertical mode by
% ending the current paragraph. \textbackslash widowpenalty is inserted so that
% no page break will happen usually. If the user desires a page break, then she
% can simply use \textbackslash par directly.
%
%    \begin{macrocode}
  \if_mode_horizontal:
    % TODO: Make configurable/section by default penalty?
    \tex_par:D
    \tex_penalty:D \tex_widowpenalty:D
  \fi:

  \group_begin:%

%    \end{macrocode}
%
% First we define the height and depth of the box that will be set. Setting the
% height works by inserting a rule into the first box and adding a negative
% skip afterwards. The depth is compensated by simply telling LaTeX what the
% previous depth was.
%
% Note that we need to add nobreak/nointerlineskip everywhere so that we
% don't insert extra spacing and no page break will happen.
%
% The first box has a defined height and stores the current position for the
% frame code later on. Then two cleaders follow which simply implement the
% required stretching (cleaders are used to prevent page breaking, I do not
% know whether this is sane, but it seems to work just fine). After this the
% box containing the main drawing code is placed last. We simply use a vbox
% with right aligned content.
%
%
%    \begin{macrocode}
    % TODO: Make this configurable
    \dim_set:Nn \l__sdaps_textbox_dp_dim { 0.5ex }
    \dim_set:Nn \l__sdaps_textbox_ht_dim { 1.7ex }

    \vbox:n {
      \noindent
      \leftskip=0pt
      \rightskip=0pt plus 1fill
      \tex_vrule:D height \l__sdaps_textbox_ht_dim depth 0pt width 0pt
      \pgfsys@markposition{textboxtop\int_use:N\g__sdaps_textbox_num_int}
    }

    \tex_penalty:D 10000
    \tex_prevdepth:D=-1000pt

    \tex_expandafter:D\tex_cleaders:D\tex_hbox:D{}\skip_vertical:n{#1 - \l__sdaps_textbox_ht_dim}

    \tex_penalty:D 10000
    \tex_prevdepth:D=-1000pt

    \tex_expandafter:D\tex_cleaders:D\tex_hbox:D{}\skip_vertical:n{\stretch{1}}

    \tex_penalty:D 10000
    \tex_prevdepth:D=-1000pt

    \vbox:n {
      \noindent
      \leftskip=0pt plus 1fill
      \rightskip=0pt
      \begin{tikzpicture}[remember~picture,overlay,shift=(current~page.south~west)]
        \pgfsys@getposition{pgfpageorigin}{\@sdaps@pageorigin}
        \pgfsys@getposition{textboxtop\int_use:N\g__sdaps_textbox_num_int}{\@sdaps@textboxtoppos}
        \pgfpointadd{\@sdaps@textboxtoppos}{
          \pgfpointadd{\@sdaps@pageorigin}{\pgfpoint{0}{\l__sdaps_textbox_ht_dim}}
        }
        \pgfgetlastxy{\l__sdaps_x}{\l__sdaps_y}
        \dim_set:Nn \l_sdaps_x_dim {\l__sdaps_x}
        \dim_set:Nn \l_sdaps_y_dim {\l__sdaps_y}

        \pgfsys@getposition{\pgfpictureid}{\@sdaps@textboxbottompos}
        \pgfpointdiff{\@sdaps@textboxtoppos}{\@sdaps@textboxbottompos}

        % Is there a more elegant way to multiply the height with -1?
        \pgfgetlastxy{\l__sdaps_width}{\l__sdaps_height}
        % Add the minimum height (i.e. depth below the last baseline) to the
        % overall height.
        \pgfpoint{\l__sdaps_width}{-\l__sdaps_height + \l__sdaps_textbox_ht_dim}
        \pgfgetlastxy{\l__sdaps_width}{\l__sdaps_height}
        \dim_set:Nn \l_sdaps_width_dim {\l__sdaps_width}
        \dim_set:Nn \l_sdaps_height_dim {\l__sdaps_height}

        % Draw the rectangle
        \draw[line~width=1bp] ($(\l_sdaps_x_dim, \l_sdaps_y_dim) + 0.5 * (1bp, -1bp)$) rectangle +($(\l_sdaps_width_dim, -\l_sdaps_height_dim) - (1bp, -1bp)$);

        \begin{scope}
          \seq_map_inline:Nn \g__sdaps_textbox_overlays_seq {##1}
        \end{scope}

        \sdaps_info_write_x:x {
          Box=Textbox,
          \exp_not:n{\int_use:N\g_sdaps_page_int},
          \dim_use:N \l_sdaps_x_dim,
          \dim_use:N \l_sdaps_y_dim,
          \dim_use:N \l_sdaps_width_dim,
          \dim_use:N \l_sdaps_height_dim
        }
      \end{tikzpicture}
    }
    \tex_prevdepth:D=\l__sdaps_textbox_dp_dim

    \int_gincr:N\g__sdaps_textbox_num_int

  \group_end:
}


\cs_new_protected:Nn \__sdaps_textbox_hstretch:nnnn
{
  \group_begin:

    % Place a vrule to make space for the top/bottom padding
    \tex_vrule:D depth #1 height #2 width 0pt \nobreak
    \pgfsys@markposition{textboxstart\int_use:N\g__sdaps_textbox_num_int} \nobreak

    \skip_horizontal:n { #3 + \stretch{#4} } \nobreak

    % The textbox (rendered on the background)
    \begin{tikzpicture}[remember~picture,overlay,shift=(current~page.south~west)]
      \pgfsys@getposition{pgfpageorigin}{\@sdaps@pageorigin}
      \pgfsys@getposition{textboxstart\int_use:N\g__sdaps_textbox_num_int}{\@sdaps@textboxpos}
      % The position here is the position of the baseline.
      % So move up by height (param 2) to get the correct vertical position.
      \pgfpointadd{\@sdaps@textboxpos}{
        \pgfpointadd{\@sdaps@pageorigin}{\pgfpoint{0}{#2}}
      }
      \pgfgetlastxy{\l__sdaps_x}{\l__sdaps_y}
      \dim_set:Nn \l_sdaps_x_dim {\l__sdaps_x}
      \dim_set:Nn \l_sdaps_y_dim {\l__sdaps_y}

      \pgfsys@getposition{\pgfpictureid}{\@sdaps@textboxendpos}
      % Calculate width and add the height to it
      \pgfpointadd{
        \pgfpointdiff{\@sdaps@textboxpos}{\@sdaps@textboxendpos}
      }{\pgfpoint{0pt}{#1 + #2}}
      \pgfgetlastxy{\l__sdaps_width}{\l__sdaps_height}
      \dim_set:Nn \l_sdaps_width_dim {\l__sdaps_width}
      \dim_set:Nn \l_sdaps_height_dim {\l__sdaps_height}

      % Draw the rectangle
      \draw[line~width=1bp,fill=white] ($(\l_sdaps_x_dim, \l_sdaps_y_dim) + 0.5 * (1bp, -1bp)$) rectangle +($(\l_sdaps_width_dim, -\l_sdaps_height_dim) - (1bp, -1bp)$);

      \begin{scope}
        \seq_map_inline:Nn \g__sdaps_textbox_overlays_seq {##1}
      \end{scope}

      \sdaps_info_write_x:x {
        Box=Textbox,
        \exp_not:n{\int_use:N\g_sdaps_page_int},
        \dim_use:N \l_sdaps_x_dim,
        \dim_use:N \l_sdaps_y_dim,
        \dim_use:N \l_sdaps_width_dim,
        \dim_use:N \l_sdaps_height_dim
      }
    \end{tikzpicture}

    \int_gincr:N\g__sdaps_textbox_num_int

  \group_end:
}

\cs_new_protected:Nn \__sdaps_textbox_prepare_coffin:
{
  \dim_set:Nn \l__sdaps_textbox_ht_dim { \coffin_ht:N \l__sdaps_textbox_coffin }
  \dim_set:Nn \l__sdaps_textbox_dp_dim { \coffin_dp:N \l__sdaps_textbox_coffin }
  \dim_set:Nn \l__sdaps_textbox_wd_dim { \coffin_wd:N \l__sdaps_textbox_coffin }

  \hcoffin_set:Nn \l_tmpa_coffin {
    \tex_vrule:D depth \l__sdaps_textbox_pad_dim height 0pt width 0pt

    \pdfsavepos

    \dim_set:Nn \l_sdaps_width_dim {\l__sdaps_textbox_wd_dim + 2\l__sdaps_textbox_pad_dim}
    \dim_set:Nn \l_sdaps_height_dim {\l__sdaps_textbox_ht_dim + \l__sdaps_textbox_dp_dim + 2\l__sdaps_textbox_pad_dim}

    % pdflast[xy]pos is the PDF position of the top left corner excluding the
    % origin
    \sdaps_info_write_x:x{
      Box=Textbox,
      \exp_not:n{\int_use:N\g_sdaps_page_int},
      \exp_not:n{\dim_eval:n {\hoffset + \the\pdflastxpos sp}},
      \exp_not:n{\dim_eval:n {\voffset + \the\pdflastypos sp}},
      \dim_use:N \l_sdaps_width_dim,
      \dim_use:N \l_sdaps_height_dim
    }

    \dim_set:Nn \l_sdaps_x_dim { 0pt }
    \dim_set:Nn \l_sdaps_y_dim { 0pt }

    % The textbox (rendered on the background)
    \begin{tikzpicture}[overlay]
      % Draw the rectangle
      \draw[line~width=1bp] ($(0, 0) + (0.5bp, -0.5bp)$) rectangle +($(\l_sdaps_width_dim, -\l_sdaps_height_dim) - (1bp, -1bp)$);

      \begin{scope}
          \seq_map_inline:Nn \g__sdaps_textbox_overlays_seq {##1}%
      \end{scope}
    \end{tikzpicture}
    \skip_horizontal:n { \l__sdaps_textbox_pad_dim }
  }

  \hcoffin_set:Nn \l_tmpb_coffin {
    \skip_horizontal:n { \l__sdaps_textbox_pad_dim }
    \tex_vrule:D depth \l__sdaps_textbox_pad_dim height 0pt width 0pt
  }

  \coffin_join:NnnNnnnn \l__sdaps_textbox_coffin { l } { t } \l_tmpa_coffin { r } { b } { 0pt } { 0pt }
  \coffin_join:NnnNnnnn \l__sdaps_textbox_coffin { r } { b } \l_tmpb_coffin { l } { t } { 0pt } { 0pt }

  \int_gincr:N\g__sdaps_textbox_num_int
}

\coffin_new:N \l__sdaps_textbox_coffin
\cs_new_protected:Nn \__sdaps_textbox_hbox:nn
{
  \group_begin:

    \hcoffin_set:Nn \l__sdaps_textbox_coffin { \tl_trim_spaces:n { #2 } }

    \dim_set:Nn \l__sdaps_textbox_pad_dim {#1}

    \__sdaps_textbox_prepare_coffin:

    \coffin_typeset:Nnnnn \l__sdaps_textbox_coffin { l } { H } { 0pt } { 0pt }

  \group_end:
}

\cs_new_protected:Nn \__sdaps_textbox_vbox:nnn
{
  \group_begin:

    \dim_set:Nn \l__sdaps_textbox_pad_dim { #2 }
    \dim_set:Nn \l__sdaps_textbox_wd_dim { #1 - 2\l__sdaps_textbox_pad_dim }

    \vcoffin_set:Nnn \l__sdaps_textbox_coffin { \l__sdaps_textbox_wd_dim } { \tl_trim_spaces:n { #3 }}

    \__sdaps_textbox_prepare_coffin:

    \coffin_typeset:Nnnnn \l__sdaps_textbox_coffin { l } { H } { 0pt } { 0pt }

  \group_end:
}

%    \end{macrocode}
%
%
% \subsection{Page Marking}
%
% SDAPS depends on certain markings on every page. The following function
% implement drawing these marks.
%
%    \begin{macrocode}

\int_new:N \g_sdaps_page_int
\int_set:Nn \g_sdaps_page_int { 0 }

\bool_new:N \g__sdaps_draft_bool
\bool_new:N \g_sdaps_twoside_bool

\bool_set:Nn \g_sdaps_draft_bool \c_true_bool
\bool_set:Nn \g_sdaps_twoside_bool \c_false_bool



\tl_new:N \g_sdaps_style_tl
\dim_new:N \g_sdaps_edge_left_margin_dim
\dim_new:N \g_sdaps_edge_right_margin_dim
\dim_new:N \g_sdaps_edge_top_margin_dim
\dim_new:N \g_sdaps_edge_bottom_margin_dim
\dim_new:N \g_sdaps_edge_marker_linewidth_dim
\dim_new:N \g_sdaps_edge_marker_length_dim

\dim_new:N \g_sdaps_classic_boxpad_dim
\dim_new:N \g_sdaps_classic_boxsize_dim


\tl_set:Nn \g_sdaps_style_tl { code128 }
\dim_set:Nn \g_sdaps_edge_left_margin_dim { 10mm }
\dim_set:Nn \g_sdaps_edge_right_margin_dim { 10mm }
\dim_set:Nn \g_sdaps_edge_top_margin_dim { 12mm }
\dim_set:Nn \g_sdaps_edge_bottom_margin_dim { 12mm }
\dim_set:Nn \g_sdaps_edge_marker_linewidth_dim { 1bp }
\dim_set:Nn \g_sdaps_edge_marker_length_dim { 20mm }

\dim_set:Nn \g_sdaps_classic_boxpad_dim { 3mm }
\dim_set:Nn \g_sdaps_classic_boxsize_dim { 3.5mm }


\tl_new:N \g_sdaps_questionnaire_id_tl
\tl_set:Nn \g_sdaps_questionnaire_id_tl { }

\tl_new:N \g_sdaps_questionnaire_id_label_tl
\tl_set:Nn \g_sdaps_questionnaire_id_label_tl { }


\tl_new:N \g_sdaps_survey_id_tl
\tl_set:Nn \g_sdaps_survey_id_tl { 32498923 }

\tl_new:N \g_sdaps_global_id_tl
\tl_set:Nn \g_sdaps_global_id_tl { }

\tl_new:N \g_sdaps_global_id_label_tl
\tl_set:Nn \g_sdaps_global_id_label_tl { }




% Settings for code128 barcodes (used in code128 style, who would have thought?)
\dim_new:N \c_sdaps_barcode_height_dim
\dim_set:Nn \c_sdaps_barcode_height_dim {6.5mm}
% This is the same as the default
\dim_new:N \c_sdaps_barcode_bar_width_dim
\dim_set:Nn \c_sdaps_barcode_bar_width_dim {0.33mm}
% Same as default. Barwidth is decreased for printing by this value.
\dim_new:N \c_sdaps_barcode_bcorr_dim
\dim_set:Nn \c_sdaps_barcode_bcorr_dim {0.020mm}

% The padding on the left/right of a barcode. This is the distance that the
% barcodes will be printed from the cornermarks
% Choosen to be the same as the barcode height. Note that the Code-128
% standard requires a quiet zone of max(10*modulesize, ~6.4mm).
\dim_new:N \c_sdaps_barcode_hpad_dim
\dim_set:Nn \c_sdaps_barcode_hpad_dim {6.5mm}

% This needs to be smaller than 6.5mm because otherwise the content is too close.
% We set it so that it forms a golden ratio 6.5mm*(sqrt(5/4)-0.5). This means
% we have about 4.5mm padding to the content.
\dim_new:N \c_sdaps_barcode_vpad_dim
\dim_set:Nn \c_sdaps_barcode_vpad_dim {4.02mm}


\cs_new_protected:Nn \sdaps_draw_codes:
{
  \group_begin:
    \begin{scope}[line~width=\g_sdaps_edge_marker_linewidth_dim, shift={(current~page.south~west)}]
      \str_if_eq:VnT \g_sdaps_style_tl { qr } {
        \tl_if_empty:VF \g_sdaps_questionnaire_id_tl {
          \begin{scope}[shift={($(\g_sdaps_edge_left_margin_dim, \g_sdaps_edge_bottom_margin_dim)$)}]
            \node(barcode)[anchor=south~west,outer~sep=0,inner~sep=0]{
              \qrcode_render:nV {version=2,level=H,padding,height=10mm} \g_sdaps_questionnaire_id_tl
            };
          \end{scope}
        }

        % We unconditionally print this barcode, it is required for the recognition
        % process.
        \begin{scope}[shift={($(\paperwidth, 0) + (-\g_sdaps_edge_right_margin_dim, \g_sdaps_edge_bottom_margin_dim)$)}]
          \pgfmathsetbasenumberlength{4}
          \pgfmathdectobase{\paddedpage}{\thepage}{10}% Yes, padding to 4 chars the hard way
          \node(barcode)[anchor=south~east,outer~sep=0,inner~sep=0]{
            \qrcode_render:nx {version=2,level=H,padding,height=10mm} {\tl_use:N\g_sdaps_survey_id_tl\paddedpage}
          };
        \end{scope}

        \tl_if_empty:VF \g_sdaps_global_id_tl {
          \begin{scope}[shift={($(\paperwidth/2-\g_sdaps_edge_right_margin_dim/2+\g_sdaps_edge_left_margin_dim/2, \g_sdaps_edge_bottom_margin_dim)$)}]
            \node(barcode)[anchor=south,outer~sep=0,inner~sep=0]{
              \qrcode_render:nV {version=2,level=H,padding,height=10mm} \g_sdaps_global_id_tl
            };
          \end{scope}
        }
      }

      \str_if_eq:VnT \g_sdaps_style_tl { code128 } {
        \tl_if_empty:VF \g_sdaps_questionnaire_id_tl {
          % TODO: do not hardcode the font!
          \ttfamily\footnotesize

          \begin{scope}[shift={($(\g_sdaps_edge_left_margin_dim, \g_sdaps_edge_bottom_margin_dim) + (\c_sdaps_barcode_hpad_dim, \c_sdaps_barcode_vpad_dim)$)}]
            \node(barcode)[anchor=south~west,outer~sep=0,inner~sep=0]{
              \X = \c_sdaps_barcode_bar_width_dim
              \bcorr = \c_sdaps_barcode_bcorr_dim
              \barheight = \c_sdaps_barcode_height_dim
              \code_render:V \g_sdaps_questionnaire_id_tl
            };
            \node[below=1mm~of~barcode,distance=0,anchor=north,outer~sep=0,inner~sep=0]{
              \tl_if_empty:VTF \g_sdaps_questionnaire_id_label_tl {
                \tl_use:N \g_sdaps_questionnaire_id_tl
              } {
                \tl_use:N \g_sdaps_questionnaire_id_label_tl
              }
            };
          \end{scope}
        }

        % We unconditionally print this barcode, it is required for the recognition
        % process.
        \begin{scope}[shift={($(\paperwidth, 0) + (-\g_sdaps_edge_right_margin_dim, \g_sdaps_edge_bottom_margin_dim) + (-\c_sdaps_barcode_hpad_dim, \c_sdaps_barcode_vpad_dim)$)}]
          \pgfmathsetbasenumberlength{4}
          \pgfmathdectobase{\paddedpage}{\thepage}{10}% Yes, padding to 4 chars the hard way
          \node(barcode)[anchor=south~east,outer~sep=0,inner~sep=0]{
            \X = \c_sdaps_barcode_bar_width_dim
            \bcorr = \c_sdaps_barcode_bcorr_dim
            \barheight = \c_sdaps_barcode_height_dim
            \code_render:x {\tl_use:N\g_sdaps_survey_id_tl \paddedpage}
          };
          \node[below=1mm~of~barcode,distance=0,anchor=north,outer~sep=0,inner~sep=0]{
            % TODO: do not hardcode the font!
            \ttfamily\footnotesize

            \tl_use:N\g_sdaps_survey_id_tl\,\paddedpage
          };
        \end{scope}

        \tl_if_empty:VF \g_sdaps_global_id_tl {
          \begin{scope}[shift={($(\paperwidth/2-\g_sdaps_edge_right_margin_dim/2+\g_sdaps_edge_left_margin_dim/2, 0) + (0, \g_sdaps_edge_bottom_margin_dim) + (0, \c_sdaps_barcode_vpad_dim)$)}]
            \node(barcode)[anchor=south,outer~sep=0,inner~sep=0]{
              \X = \c_sdaps_barcode_bar_width_dim
              \bcorr = \c_sdaps_barcode_bcorr_dim
              \barheight = \c_sdaps_barcode_height_dim
              \code_render:V \g_sdaps_global_id_tl
            };
            \node[below=1mm~of~barcode,distance=0,anchor=north,outer~sep=0,inner~sep=0]{
              % TODO: do not hardcode the font!
              \ttfamily\footnotesize

              \tl_if_empty:VTF \g_sdaps_global_id_label_tl {
                \tl_use:N \g_sdaps_global_id_tl
              } {
                \tl_use:N \g_sdaps_global_id_label_tl
              }
            };
          \end{scope}
        }
      }

      \str_if_eq:VnT \g_sdaps_style_tl { classic } {
        % TODO: This is non-working! And should be rewritten.
        \tl_if_empty:VF \g_sdaps_questionnaire_id_tl {
          \if@PrintSurveyId
            \def\@questionnaire_id_shift{\g_sdaps_classic_boxpad_dim+\codeboxheight}
          \else:
            \def\@questionnaire_id_shift{0pt}
          \fi:
          \begin{scope}[shift={($(\g_sdaps_edge_left_margin_dim, \g_sdaps_edge_bottom_margin_dim) + (2*\g_sdaps_classic_boxpad_dim, \g_sdaps_classic_boxpad_dim) + (\g_sdaps_classic_boxsize_dim, \@questionnaire_id_shift)$)}]
            \draw (0, 0) rectangle (\thecodeboxlength\codeboxstep, \codeboxheight);
            \@tempcnta=\value{questionnaireid}
            \begin{scope}[shift={(\thecodeboxlength\codeboxstep, 0)}]
              \foreach \x in {0,...,\numexpr\thecodeboxlength-1\relax}
              {
                \ifodd \@tempcnta
                  \draw[fill] (-\x\codeboxstep, 0) rectangle +(-\codeboxstep, \codeboxheight);
                \fi:
                \global\divide\@tempcnta by 2
              }
            \end{scope}
          \end{scope}
          \begin{scope}[shift={($(\paperwidth, 0) + (-\g_sdaps_edge_right_margin_dim, \g_sdaps_edge_bottom_margin_dim) + (-2*\g_sdaps_classic_boxpad_dim, \g_sdaps_classic_boxpad_dim) + (-\thecodeboxlength\codeboxstep, 0) + (-\g_sdaps_classic_boxsize_dim, \@questionnaire_id_shift)$)}]
            \draw (0, 0) rectangle (\thecodeboxlength\codeboxstep, \codeboxheight);
            \@tempcnta=\value{questionnaireid}
            \begin{scope}[shift={(\thecodeboxlength\codeboxstep, 0)}]
              \foreach \x in {0,...,\numexpr\thecodeboxlength-1\relax}
              {
                \ifodd \@tempcnta
                  \draw[fill] (-\x\codeboxstep, 0) rectangle +(-\codeboxstep, \codeboxheight);
                \fi:
                \global\divide\@tempcnta by 2
              }
            \end{scope}
          \end{scope}
          \begin{scope}[shift={($(current~page.south) + (0, \g_sdaps_edge_bottom_margin_dim) + (0, \g_sdaps_classic_boxpad_dim) + (0 ,\@questionnaire_id_shift) + (0, 0.5\codeboxheight)$)}]
            \pgfmathsetbasenumberlength{5}\pgfmathdectoBase{\@temphexa}{\value{questionnaireid}}{10}
            \node{\usekomafont{questionnaireidfont}{\translate{questionnaireid} \@temphexa}};
          \end{scope}
        \fi:
        \if@PrintSurveyId
          % survey-id
          \begin{scope}[shift={($(\g_sdaps_edge_left_margin_dim, \g_sdaps_edge_bottom_margin_dim) + (2*\g_sdaps_classic_boxpad_dim, \g_sdaps_classic_boxpad_dim) + (\g_sdaps_classic_boxsize_dim, 0)$)}]
            \draw (0, 0) rectangle (\thecodeboxlength\codeboxstep, \codeboxheight);
            \@tempcnta=\value{surveyidmshw}
            \begin{scope}[shift={(\thecodeboxlength\codeboxstep, 0)}]
              \foreach \x in {0,...,\numexpr\thecodeboxlength-1\relax}
              {
                \ifodd \@tempcnta
                  \draw[fill] (-\x\codeboxstep, 0) rectangle +(-\codeboxstep, \codeboxheight);
                \fi:
                \global\divide\@tempcnta by 2
              }
            \end{scope}
          \end{scope}
          \begin{scope}[shift={($(\paperwidth, 0) + (-\g_sdaps_edge_right_margin_dim, \g_sdaps_edge_bottom_margin_dim) + (-2*\g_sdaps_classic_boxpad_dim, \g_sdaps_classic_boxpad_dim) + (-\thecodeboxlength\codeboxstep, 0) + (-\g_sdaps_classic_boxsize_dim, 0)$)}]
            \draw (0, 0) rectangle (\thecodeboxlength\codeboxstep, \codeboxheight);
            \@tempcnta=\value{surveyidlshw}
            \begin{scope}[shift={(\thecodeboxlength\codeboxstep, 0)}]
              \foreach \x in {0,...,\numexpr\thecodeboxlength-1\relax}
              {
                \ifodd \@tempcnta
                  \draw[fill] (-\x\codeboxstep, 0) rectangle +(-\codeboxstep, \codeboxheight);
                \fi:
                \global\divide\@tempcnta by 2
              }
            \end{scope}
          \end{scope}
          \begin{scope}[shift={($(current~page.south) + (0, \g_sdaps_edge_bottom_margin_dim) + (0, \g_sdaps_classic_boxpad_dim) + (0, 0.5\codeboxheight)$)}]
            \pgfmathsetbasenumberlength{4}\pgfmathdectoBase{\@temphexa}{\value{surveyidlshw}}{16}
            \pgfmathsetbasenumberlength{4}\pgfmathdectoBase{\@temphexb}{\value{surveyidmshw}}{16}
            \node{\usekomafont{surveyidfont}{\translate{surveyid} \@temphexb\@temphexa}};
          \end{scope}
        }
      }
    \end{scope}%
  \group_end:
}

\msg_new:nnn { sdapsbase } { classic_too_many_pages } { You\ cannot\ have\ more\ than\ six\ pages\ with\ the\ classic\ style. }
\msg_new:nnn { sdapsbase } { odd_page_count } { You\ have\ an\ odd\ number\ of\ pages,\ this\ does\ not\ work\ in\ duplex\ mode! }

% This needs to be called once for each page!
\cs_new_protected:Nn \sdaps_page_end: {
  \group_begin:

    \int_gincr:N\g_sdaps_page_int%

    \normalfont%

    \begin{tikzpicture}[remember~picture,overlay]%

      %---------------------------------------------------------------------------
      % corner marks and corner boxes in classic mode
      %---------------------------------------------------------------------------
      \begin{scope}[line~width=\g_sdaps_edge_marker_linewidth_dim, line~join=miter]
        \begin{scope}[shift={($(current~page.north~west) + (\g_sdaps_edge_left_margin_dim, -\g_sdaps_edge_top_margin_dim)$)}]
          \draw (0,-\g_sdaps_edge_marker_length_dim) -- (0, 0) -- (\g_sdaps_edge_marker_length_dim,0);

          \str_if_eq:VnT \g_sdaps_style_tl { classic } {
            % TODO: Is the filled/non-filled mapping still correct?
            \int_case:nnTF \g_sdaps_page_int {
              { 1 } { \draw }
              { 2 } { \fill }
              { 3 } { \fill }
              { 4 } { \fill }
              { 5 } { \fill }
              { 6 } { \draw }
            } {
              (\g_sdaps_classic_boxpad_dim, -\g_sdaps_classic_boxpad_dim) rectangle +(\g_sdaps_classic_boxsize_dim,-\g_sdaps_classic_boxsize_dim);
            } {
              % Error out (first time)
              \msg_error:nn { sdapsbase } { classic_too_many_pages }
            }
          }
        \end{scope}
        \begin{scope}[shift={($(current~page.north~east) + (-\g_sdaps_edge_right_margin_dim, -\g_sdaps_edge_top_margin_dim)$)}]
          \draw (0,-\g_sdaps_edge_marker_length_dim) -- (0,0) -- (-\g_sdaps_edge_marker_length_dim,0);

          \str_if_eq:VnT \g_sdaps_style_tl { classic } {
            % TODO: Is the filled/non-filled mapping still correct?
            \int_case:nnT \g_sdaps_page_int {
              { 1 } { \fill }
              { 2 } { \fill }
              { 3 } { \draw }
              { 4 } { \draw }
              { 5 } { \draw }
              { 6 } { \draw }
            } {
              (-\g_sdaps_classic_boxpad_dim, -\g_sdaps_classic_boxpad_dim) rectangle +(-\g_sdaps_classic_boxsize_dim,-\g_sdaps_classic_boxsize_dim);
            }
          }
        \end{scope}
        \begin{scope}[shift={($(current~page.south~west) + (\g_sdaps_edge_left_margin_dim, \g_sdaps_edge_bottom_margin_dim)$)}]
          \draw (0,\g_sdaps_edge_marker_length_dim) -- (0, 0) -- (\g_sdaps_edge_marker_length_dim,0);

          \str_if_eq:VnT \g_sdaps_style_tl { classic } {
            % TODO: Is the filled/non-filled mapping still correct?
            \int_case:nnT \g_sdaps_page_int {
              { 1 } { \fill }
              { 2 } { \draw }
              { 3 } { \fill }
              { 4 } { \fill }
              { 5 } { \draw }
              { 6 } { \draw }
            } {
              (\g_sdaps_classic_boxpad_dim, \g_sdaps_classic_boxpad_dim) rectangle +(\g_sdaps_classic_boxsize_dim,\g_sdaps_classic_boxsize_dim);
            }
          }
        \end{scope}
        \begin{scope}[shift={($(current~page.south~east) + (-\g_sdaps_edge_right_margin_dim, \g_sdaps_edge_bottom_margin_dim)$)}]
          \draw (0,\g_sdaps_edge_marker_length_dim) -- (0mm, 0mm) -- (-\g_sdaps_edge_marker_length_dim,0);

          \str_if_eq:VnT \g_sdaps_style_tl { classic } {
            % TODO: Is the filled/non-filled mapping still correct?
            \int_case:nnT \g_sdaps_page_int {
              { 1 } { \fill }
              { 2 } { \draw }
              { 3 } { \fill }
              { 4 } { \draw }
              { 5 } { \draw }
              { 6 } { \fill }
            } {
              (-\g_sdaps_classic_boxpad_dim, \g_sdaps_classic_boxpad_dim) rectangle +(-\g_sdaps_classic_boxsize_dim,\g_sdaps_classic_boxsize_dim);
            }
          }
        \end{scope}
      \end{scope}

      %---------------------------------------------------------------------------
      % barcodes/qr codes
      %---------------------------------------------------------------------------
      \bool_if:NTF \g__sdaps_last_page_bool {

        \int_compare:nNnTF { \g_sdaps_page_int } = { 1 } {
          % if we have a one page document, just always stamp the last
          % page. This means that SDAPS can fall back to simplex mode
          % automatically.
          \sdaps_draw_codes:
        } {

          \int_if_odd:VTF \g_sdaps_page_int {
            \msg_error:nn { sdapsbase } { odd_page_count }
          } {
            % questionnaire-id
            \sdaps_draw_codes:
          }
        }

        % TODO: Check whether the page count is as expected?
      } {
        \bool_if:NTF \g_sdaps_twoside_bool {
          \int_if_odd:VF \g_sdaps_page_int {
            \sdaps_draw_codes:
          }
        } {
          \sdaps_draw_codes:
        }
      }

      %---------------------------------------------------------------------------
      % watermark for non final mode
      %---------------------------------------------------------------------------
      \bool_if:NT \g_sdaps_draft_bool {
        \node [rotate=60,scale=10,text~opacity=0.2,color=red]
           at (current~page.center) {\textsc{draft}};
      }
    \end{tikzpicture}

  \group_end:
}


%    \end{macrocode}
%
% \subsection{Starting/Ending an SDAPS context}
%
% These need to be used to begin rendering into an SDAPS context and finishing
% everything off.
%
% Note that this base package does not automatically call
% \textbackslash sdaps\_page\_end: for
% you, so if you are using this class directly you will need to make sure that
% this handler is called after all form elements on a page. An easy of doing
% this is to call it from inside the page footer.
%
%
%    %\begin{macrocode}

\cs_new_protected:Nn \sdaps_begin: {
  \bool_gset:Nn \g__sdaps_last_page_bool \c_false_bool

  % TODO: We really want to make sure nobody modifies the values after \sdaps_begin:
  \sdaps_info_write:x{Duplex=\bool_if:NTF \g_sdaps_twoside_bool {true} {false}}
  \sdaps_info_write:x{
    PageSize=\the\paperwidth, \the\paperheight
  }
  \sdaps_info_write:x{Style=\g_sdaps_style_tl}
  \sdaps_info_write:x{CheckMode=checkcorrect}

  \int_gset:Nn \g_sdaps_page_int { 0 }
}

\cs_new_protected:Nn \sdaps_end: {
  \sdaps_info_write_x:n{Pages=\int_use:N\g_sdaps_page_int}

  \bool_gset:Nn \g__sdaps_last_page_bool \c_true_bool
}


%
%    \end{macrocode}
%

% \Finale
\endinput
